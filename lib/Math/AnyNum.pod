=encoding utf8

=head1 NAME

Math::AnyNum - Arbitrary size precision for integers, rationals, floating-points and complex numbers.

=head1 VERSION

Version 0.38

=head1 SYNOPSIS

Math::AnyNum provides a transparent and easy-to-use interface to L<Math::GMPz>, L<Math::GMPq>, L<Math::MPFR> and L<Math::MPC>, along with a decent number of useful mathematical functions.

    use 5.016;
    use Math::AnyNum qw(:overload factorial);

    # Integers
    say factorial(30);              #=> 265252859812191058636308480000000

    # Floating-point numbers
    say sqrt(1 / factorial(100));   #=> 1.0351378111756264713204945[...]e-79

    # Rational numbers
    my $x = 2/3;
    say ($x * 3);                   #=> 2
    say (2 / $x);                   #=> 3
    say $x;                         #=> 2/3

    # Complex numbers
    say 3 + 4*i;                    #=> 3+4i
    say sqrt(-4);                   #=> 2i
    say log(-1);                    #=> 3.1415926535897932384626433832[...]i

=head1 DESCRIPTION

Math::AnyNum focuses primarily on providing a friendly interface and good performance. In most cases, it can be used as
a drop-in replacement for the L<bignum> and L<bigrat> pragmas.

The philosophy of Math::AnyNum is that mathematics should just work, therefore the support for complex numbers is virtually transparent,
without requiring any explicit conversions. All the conversions are done implicitly, using a fairly sophisticated promotion system,
which tries really hard to do the right thing and as efficiently as possible.

Additionally, each Math::AnyNum object is B<immutable>.

=head1 FUNCTIONS

  :ntheory

    binomial(n,k)             binomial coefficient
    multinomial(@list)        multinomial coefficient
    factorial(n)              product of first n positive integers: n!
    dfactorial(n)             double-factorial: n!!
    mfactorial(n,k)           multi-factorial: n*(n-k)*(n-2k)*...
    subfactorial(n)           number of derangements: !n
    subfactorial(n,k)         number of derangements with k fixed points
    superfactorial(n)         product of first n factorials
    hyperfactorial(n)         product of k^k for k=1..n
    rising_factorial(n,k)     rising factorial: n^(k)
    falling_factorial(n,k)    falling factorial: (n)_k
    bell(n)                   n-th Bell number
    catalan(n)                n-th Catalan number
    catalan(n,k)              C(n,k) entry in Catalan's triangle
    lucas(n)                  n-th Lucas number
    lucasmod(n,m)             n-th Lucas number modulo m
    lucasU(P,Q,n)             Lucas U_n(P, Q) function
    lucasV(P,Q,n)             Lucas V_n(P, Q) function
    lucasUmod(P,Q,n,m)        Lucas U_n(P, Q) modulo m
    lucasVmod(P,Q,n,m)        Lucas V_n(P, Q) modulo m
    fibonacci(n)              n-th Fibonacci number
    fibonacci(n,k)            n-th Fibonacci number of k-th order
    fibmod(n,m)               n-th Fibonacci number modulo m
    polygonal(n,k)            n-th k-gonal number
    harmonic(n)               n-th harmonic number: 1 + 1/2 + ... + 1/n
    secant_number(n)          n-th secant/zig number
    tangent_number(n)         n-th tangent/zag number
    euler(n)                  n-th Euler number: E_n
    euler(n,x)                Euler polynomials: E_n(x)
    bernoulli(n)              n-th Bernoulli number: B_n
    bernoulli(n,x)            Bernoulli polynomials: B_n(x)
    faulhaber(n,x)            Faulhaber polynomials: F_n(x)
    laguerreL(n,x)            Laguerre polynomials: L_n(x)
    legendreP(n,x)            Legendre polynomials: P_n(x)
    hermiteH(n,x)             Physicists' Hermite polynomials: H_n(x)
    hermiteHe(n,x)            Probabilists' Hermite polynomials: He_n(x)
    chebyshevT(n,x)           Chebyshev polynomials of the 1st kind: T_n(x)
    chebyshevU(n,x)           Chebyshev polynomials of the 2nd kind: U_n(x)
    faulhaber_sum(n,k)        sum of powers: 1^k + 2^k + ... + n^k
    geometric_sum(n,r)        geometric sum: r^0 + r^1 + ... + r^n
    dirichlet_sum(n,f,g,F,G)  Dirichlet hyperbola method
    kronecker(n,k)            Kronecker (Jacobi) symbol
    lcm(@list)                least common multiple
    gcd(@list)                greatest common divisor
    gcdext(n,k)               return (u,v,d) where u*n+v*k=d
    iadd(a,b)                 integer addition: a+b
    isub(a,b)                 integer subtraction: a-b
    imul(a,b)                 integer multiplication: a*b
    idiv(a,b)                 floor division: floor(a/b)
    idiv_ceil(a,b)            ceil division: int(a/b)
    idiv_round(a,b)           round division: int(a/b)
    idiv_trunc(a,b)           truncated division: trunc(a/b)
    imod(a,b)                 integer remainder: a%b
    ipow(n,k)                 integer exponentiation: n^k
    ipow2(k)                  integer exponentiation: 2^k
    ipow10(k)                 integer exponentiation: 10^k
    iroot(n,k)                integer k-th root of n
    isqrt(n)                  integer square root of n
    icbrt(n)                  integer cube root of n
    ilog(n,k)                 integer logarithm of n to base k
    ilog2(n)                  integer logarithm of n to base 2
    ilog10(n)                 integer logarithm of n to base 10
    addmod(a,b,m)             modular integer addition: (a+b)%m
    submod(a,b,m)             modular integer subtraction: (a-b)%m
    mulmod(a,b,m)             modular integer multiplication: (a*b)%m
    divmod(a,b,m)             modular integer division: (a/b)%m
    divmod(a,b)               quotient and remainder of a/b
    invmod(n,m)               multiplicative inverse of n modulo m
    powmod(a,b,m)             modular exponentiation: a ^ b mod m
    isqrtrem(n)               integer sqrt remainder: n - isqrt(n)^2
    irootrem(n,k)             integer root remainder: n - iroot(n,k)^k
    is_square(n)              return 1 if n is a perfect square
    is_power(n)               return 1 if n = c^k for integers c, k > 1
    is_power(n,k)             return 1 if n = c^k for integers c, k
    is_polygonal(n,k)         return 1 if n is a first k-gonal number
    is_polygonal2(n,k)        return 1 if n is a second k-gonal number
    is_coprime(n,k)           return 1 if gcd(n,k) = 1
    is_rough(n,B)             return 1 if all prime factors of n are >= B
    is_smooth(n,B)            return 1 if all prime factors of n are <= B
    is_smooth_over_prod(n,k)  return 1 if n is smooth over the primes p|k
    rough_part(n,B)           largest B-rough divisor of n
    smooth_part(n,B)          largest B-smooth divisor of n
    make_coprime(n,k)         largest divisor of n coprime to k
    is_prime(n,r=23)          Miller-Rabin primality test
    primorial(n)              product of primes <= n
    next_prime(n)             next prime > n
    valuation(n,k)            number of times n is divisible by k
    remdiv(n,k)               n / k^valuation(n,k)
    ipolygonal_root(n,k)      first integer k-gonal root of n
    ipolygonal_root2(n,k)     second integer k-gonal root of n

  :special

    beta(x,y)                    Beta function
    eta(x)                       Dirichlet eta function η(x)
    gamma(x)                     Gamma function Γ(x)
    lgamma(x)                    natural logarithm of abs(Γ(x))
    lngamma(x)                   natural logarithm of Γ(x)
    lnsuperfactorial(n)          natural logarithm of superfactorial(n)
    lnhyperfactorial(n)          natural logarithm of hyperfactorial(n)
    digamma(x)                   Digamma function ψ(x)
    zeta(x)                      Zeta function ζ(x)
    Ai(x)                        Airy function
    Ei(x)                        exponential integral function
    Li(x)                        logarithmic integral function
    Li2(x)                       dilogarithm function
    lgrt(x)                      logarithmic-root: lgrt(x^x) = x
    LambertW(x)                  Lambert W function
    BesselJ(x,n)                 first order Bessel function J_n(x)
    BesselY(x,n)                 second order Bessel function Y_n(x)
    pow(x,y)                     power function: x^y
    sqr(x)                       square function: x^2
    sqrt(x)                      square root function: x^(1/2)
    cbrt(x)                      cube root function: x^(1/3)
    root(x,y)                    root function: x^(1/y)
    exp(x)                       exponential function: e^x
    exp2(x)                      exponential function: 2^x
    exp10(x)                     exponential function: 10^x
    ln(x)                        natural logarithm of x
    log(x,y)                     logarithm of x to base y
    log2(x)                      logarithm of x to base 2
    log10(x)                     logarithm of x to base 10
    mod(x,y)                     remainder of x/y
    polymod(n,@list)             n modulo a list of numbers
    erf(x)                       the Gauss error function
    erfc(x)                      the complementary error function
    abs(x)                       absolute value of x
    agm(x,y)                     arithmetic-geometric mean
    hypot(x,y)                   hypotenuse: sqrt(x^2 + y^2)
    norm(x)                      normalized value of x: abs(x)^2
    lnbern(n)                    natural logarithm of bernoulli(n)
    bernreal(n)                  Bernoulli number as floating-point
    harmreal(n)                  Harmonic number as floating-point
    polygonal_root(n,k)          first k-gonal root of n
    polygonal_root2(n,k)         second k-gonal root of n

  :trig

    sin(x)              trigonometric sine function
    cos(x)              trigonometric cosine function
    tan(x)              trigonometric tangent function
    csc(x)              trigonometric cosecant function
    sec(x)              trigonometric secant function
    cot(x)              trigonometric cotangent function

    asin(x)             inverse of trigonometric sine
    acos(x)             inverse of trigonometric cosine
    atan(x)             inverse of trigonometric tangent
    acsc(x)             inverse of trigonometric cosecant
    asec(x)             inverse of trigonometric secant
    acot(x)             inverse of trigonometric cotangent

    sinh(x)             hyperbolic sine function
    cosh(x)             hyperbolic cosine function
    tanh(x)             hyperbolic tangent function
    csch(x)             hyperbolic cosecant function
    sech(x)             hyperbolic secant function
    coth(x)             hyperbolic cotangent function

    asinh(x)            inverse of hyperbolic sine
    acosh(x)            inverse of hyperbolic cosine function
    atanh(x)            inverse of hyperbolic tangent
    acsch(x)            inverse of hyperbolic cosecant
    asech(x)            inverse of hyperbolic secant
    acoth(x)            inverse of hyperbolic cotangent

    atan2(x,y)          two-argument variant of arctangent
    rad2deg(x)          convert radians to degrees
    deg2rad(x)          convert degrees to radians

  :misc

    rand(a)             pseudorandom floating-point: 0 <= R < a
    rand(a,b)           pseudorandom floating-point: a <= R < b
    irand(a)            pseudorandom integer: 0 <= R <= a
    irand(a,b)          pseudorandom integer: a <= R <= b
    seed(n)             re-seed the `rand()` function
    iseed(n)            re-seed the `irand()` function
    int(x)              truncate x to an integer
    floor(x)            round x towards -Infinity
    ceil(x)             round x towards +Infinity
    round(x)            round x to the nearest integer
    round(x,+k)         round x to k places before the decimal point
    round(x,-k)         round x to k places after the decimal point
    acmp(a,b)           absolute comparison: abs(a) <=> abs(b)
    approx_cmp(a,b,k)   approximate comparison: round(a,k) <=> round(b,k)
    rat(x)              convert x to a rational number
    rat(str)            parse a decimal expansion as an exact fraction
    rat_approx(x)       rational approximation of a real number x
    ratmod(r,m)         rational modular operation as an integer: r % m
    numerator(r)        numerator of rational number r
    denominator(r)      denominator of rational number r
    nude(r)             numerator and denominator of r
    float(x)            convert x to a floating-point number
    complex(x)          convert x to a floating-point complex number
    complex(a,b)        complex number: a + b*i
    real(z)             real part of complex number z
    imag(z)             imaginary part of complex number z
    reals(z)            real and imaginary part of z as reals
    sgn(x)              -1 if x < 0; 0 if x = 0; 1 if x > 0
    neg(x)              additive inverse of x: -x
    inv(x)              multiplicative inverse of x: 1/x
    conj(x)             complex conjugate of x
    digits(n,b)         digits of n in base b
    digits2num(\@d,b)   conversion of digits in base b to an integer
    sumdigits(n,b)      sum of digits of n in base b
    popcount(n)         number of 1's in binary representation of n
    hamdist(n,k)        number of bit-positions where the bits differ
    getbit(n,k)         k-th bit of integer n (1 or 0)
    setbit(n,k)         set the k-th bit of integer n to 1
    clearbit(n,k)       set the k-th bit of integer n to 0
    flipbit(n,k)        flip the k-th bit of integer n
    bit_scan0(n,k)      index of the first 0-bit of n with index >= k
    bit_scan1(n,k)      index of the first 1-bit of n with index >= k

    min(@list)          minimum value from a given list of numbers
    max(@list)          maximum value from a given list of numbers

    sum(@list)          sum of a list of numbers
    prod(@list)         product of a list of numbers

    bsearch(n,\&f)      binary search from 0 to n (exact match)
    bsearch(a,b,\&f)    binary search from a to b (exact match)
    bsearch_le(n,\&f)   binary search from 0 to n (less than or equal to)
    bsearch_le(a,b,\&f) binary search from a to b (less than or equal to)
    bsearch_ge(n,\&f)   binary search from 0 to n (greater than or equal to)
    bsearch_ge(a,b,\&f) binary search from a to b (greater than or equal to)

    base(n,b)           string-representation of n in base b
    as_bin(n)           binary string-representation of n
    as_oct(n)           octal string-representation of n
    as_hex(n)           hexadecimal string-representation of n
    as_int(n,b)         integer string-representation of n in base b
    as_rat(n,b)         rational string-representation of n in base b
    as_frac(n,b)        fraction string-representation of n in base b
    as_dec(n,d)         decimal string-expansion of n with d digits

    is_pos(n)           return 1 if n > 0
    is_neg(n)           return 1 if n < 0
    is_int(n)           return 1 if n is an integer
    is_rat(n)           return 1 if n is a rational number
    is_real(n)          return 1 if n is a real number
    is_imag(n)          return 1 if n is an imaginary number
    is_complex(n)       return 1 if n is a complex number
    is_inf(n)           return 1 if n is +Infinity
    is_ninf(n)          return 1 if n is -Infinity
    is_nan(n)           return 1 if n is Not-a-Number (NaN)
    is_zero(n)          return 1 if n = 0
    is_one(n)           return 1 if n = 1
    is_mone(n)          return 1 if n = -1
    is_even(n)          return 1 if n is an integer divisible by 2
    is_odd(n)           return 1 if n is an integer not divisible by 2
    is_div(n,k)         return 1 if n is exactly divisible by k
    is_congruent(n,k,m) return 1 if n is congruent to k mod m

=head1 EXPORT

Each function can be exported individually, as:

    use Math::AnyNum qw(zeta);

There is also the possibility of exporting an entire group of functions, as:

    use Math::AnyNum qw(:trig);

Additionally, by specifying the C<:all> keyword, will export all the exportable functions and all the constants.

    use Math::AnyNum qw(:all);

The C<:overload> keyword enables constant overloading, which makes
each number a Math::AnyNum object and also exports the C<i>, C<Inf>
and C<NaN> constants:

    use Math::AnyNum qw(:overload);
    say 42;                                       #=> "42"   (as Int)
    say 1/2;                                      #=> "1/2"  (as Rat)
    say 0.5;                                      #=> "0.5"  (as Float)
    say 3 + 4*i;                                  #=> "3+4i" (as Complex)

B<NOTE:> C<:overload> is lexical to the current scope only.

The syntax for disabling the C<:overload> behavior in the current scope, is:

    no Math::AnyNum;        # :overload will be disabled in the current scope

In addition to the exportable functions, Math::AnyNum also provides a list with
useful mathematical constants that can be exported, such as:

    i           # imaginary unit             sqrt(-1)
    e           # e mathematical constant    2.718281828459...
    pi          # PI constant                3.141592653589...
    tau         # TAU constant               6.283185307179...
    ln2         # natural logarithm of 2     0.693147180559...
    phi         # golden ratio               1.618033988749...
    EulerGamma  # Euler-Mascheroni constant  0.577215664901...
    CatalanG    # Catalan G constant         0.915965594177...
    Inf         # positive Infinity
    NaN         # Not-a-Number

The syntax for exporting a constant, is:

    use Math::AnyNum qw(pi);
    say pi;                          # 3.141592653589...

Nothing is exported by default.

=head1 HOW IT WORKS

Internally, each Math::AnyNum object holds a reference to an object of type L<Math::GMPz>, L<Math::GMPq>, L<Math::MPFR> or L<Math::MPC>.
Based on the internal types, it decides what functions to call on each operation and does automatic promotion whenever is necessary.

The promotion rules can be summarized as follows:

    (Integer, Integer)   -> Integer  | Rational | Float   | Complex
    (Integer, Rational)  -> Rational | Float    | Complex
    (Integer, Float)     -> Float    | Complex
    (Integer, Complex)   -> Complex

    (Rational, Rational) -> Rational | Float    | Complex
    (Rational, Float)    -> Float    | Complex
    (Rational, Complex)  -> Complex

    (Float, Float)       -> Float    | Complex
    (Float, Complex)     -> Complex

    (Complex, Complex)   -> Complex

For explicit conversions, Math::AnyNum provides the following functions:

    int(x)          # converts x to an integer (NaN if not possible)
    rat(x)          # converts x to a rational (NaN if not possible)
    float(x)        # converts x to a real or complex floating-point number
    complex(x)      # converts x to a complex floating-point number

=head1 PRECISION

The default precision for floating-point numbers is 192 bits, which is equivalent with about
50 digits of precision in base 10.

The precision can be changed by modifying the C<$Math::AnyNum::PREC> variable, such as:

    local $Math::AnyNum::PREC = 1024;

or by specifying the precision at import (this sets the precision globally):

    use Math::AnyNum PREC => 1024;

This precision is used internally whenever a C<Math::MPFR> or a C<Math::MPC> object is created.

For example, if we change the precision to 3 decimal digits (where C<4> is the conversion factor),
we get the following results:

    local $Math::AnyNum::PREC = 3*4;

    # Floating-points
    say sqrt(2);                                  #=> 1.41
    say sqrt(19+13*i);                            #=> 4.58+1.42i

    # Integers
    say 98**7;                                    #=> 86812553324672

    # Rationals
    say 1 / 98**7                                 #=> 1/86812553324672

Notice that integers and rational numbers do not obey this precision, because they can grow and
shrink dynamically, without a specific limit.

Furthermore, a rational number never losses precision or accuracy in rational operations, therefore if we say:

    my $x = 1/3;
    say $x*3;                                     #=> 1
    say 1/$x;                                     #=> 3
    say 3/$x;                                     #=> 9

...the results are exact.

=head1 NOTATIONS

Methods that begin with an B<i> followed by the actual name (e.g.: C<isqrt>),
do integer operations, by first truncating their arguments to integers, if necessary.

The returned types are noted as follows:

    Any         # any type of number
    Int         # an integer value
    Rat         # a rational value
    Float       # a floating-point value
    Complex     # a floating-point complex value
    NaN         # "Not-a-Number" value
    Inf         # +/-Infinity
    Bool        # a Boolean value (1 or 0)
    Scalar      # a Perl scalar

When two or more types are separated with pipe characters (B<|>), it means that the
corresponding function can return any of the specified types.

=head1 INITIALIZATION / CONSTANTS

This section includes methods for creating new B<Math::AnyNum> objects
and some useful mathematical constants.

=head2 new

    Math::AnyNum->new(n)                          #=> Any
    Math::AnyNum->new(n, base)                    #=> Any

Returns a new AnyNum object with the value specified in the first argument,
which can be a Perl numerical value, a string representing a number in a
rational form, such as C<"1/2">, a string holding a decimal expansion number,
such as C<"0.5">, a string holding an integer, such as C<"255"> or a string
holding a complex number, such as C<"3+4i"> or C<"(3 4)">.

    my $z = Math::AnyNum->new('42');        # integer
    my $r = Math::AnyNum->new('3/4');       # rational
    my $f = Math::AnyNum->new('12.34');     # float
    my $c = Math::AnyNum->new('3.1+4i');    # complex

The second argument specifies the base of the number, which must be between 2 and 62.

When no base is specified, it defaults to base 10.

For setting an hexadecimal number, we can say:

    my $n = Math::AnyNum->new("deadbeef", 16);

B<NOTE:> no prefix, such as C<"0x"> or C<"0b">, is allowed as part of the number.

=head2 new_si

    Math::AnyNum->new_si(n)                       #=> Int

Sets a I<signed> native integer.

Example:

    my $n = Math::AnyNum->new_si(-42);

=head2 new_ui

    Math::AnyNum->new_ui(n)                       #=> Int

Sets an I<unsigned> native integer.

Example:

    my $n = Math::AnyNum->new_ui(42);

=head2 new_z

    Math::AnyNum->new_z(str)                      #=> Int
    Math::AnyNum->new_z(str, base)                #=> Int

Sets an arbitrary large integer from a given string.

The second argument specifies the base of the number, which must be between 2 and 62.

When no base is specified, it defaults to base 10.

Example:

    my $n = Math::AnyNum->new_z("12345678910111213141516");
    my $m = Math::AnyNum->new_z("fffffffffffffffffff", 16);

=head2 new_q

    Math::AnyNum->new_q(frac)                     #=> Rat
    Math::AnyNum->new_q(num, den)                 #=> Rat
    Math::AnyNum->new_q(num, den, base)           #=> Rat

Sets an arbitrary large rational from a given string.

The third argument specifies the base of the number, which must be between 2 and 62.

When no base is specified, it defaults to base 10.

Example:

    my $n = Math::AnyNum->new_q('12345/67890');         # 823/4526
    my $m = Math::AnyNum->new_q('12345', '67890');      # 823/4526
    my $o = Math::AnyNum->new_q('fffff', 'aaaaa', 16);  # 1048575/699050 = 3/2

=head2 new_f

    Math::AnyNum->new_f(str)                      #=> Float
    Math::AnyNum->new_f(str, base)                #=> Float

Sets a floating-point real number from a given string.

The second argument specifies the base of the number, which must be between 2 and 62.

When no base is specified, it defaults to base 10.

Example:

    my $n = Math::AnyNum->new_f('12.345');          # 12.345
    my $m = Math::AnyNum->new_f('-1.2345e-12');     # -0.0000000000012345
    my $o = Math::AnyNum->new_f('ffffff', 16);      # 16777215

=head2 new_c

    Math::AnyNum->new_c(real)                     #=> Complex
    Math::AnyNum->new_c(real, imag)               #=> Complex
    Math::AnyNum->new_c(real, imag, base)         #=> Complex

Sets a complex number from a given string.

The third argument specifies the base of the number, which must be between 2 and 62.

When no base is specified, it defaults to base 10.

Example:

    my $n = Math::AnyNum->new_c('1.123');           # 1.123
    my $m = Math::AnyNum->new_c('3', '4');          # 3+4i
    my $o = Math::AnyNum->new_c('f', 'a', 16);      # 15+10i

=head2 nan

    Math::AnyNum->nan                             #=> NaN

Returns an object holding the C<NaN> value.

=head2 inf

    Math::AnyNum->inf                             #=> Inf

Returns an object representing positive infinity.

=head2 ninf

    Math::AnyNum->ninf                            #=> -Inf

Returns an object representing negative infinity.

=head2 one

    Math::AnyNum->one                             #=> Int

Returns an object containing the value C<1>.

=head2 mone

    Math::AnyNum->mone                            #=> Int

Returns an object containing the value C<-1>.

=head2 zero

    Math::AnyNum->zero                            #=> Int

Returns an object containing the value C<0>.

=head2 i

    Math::AnyNum->i                               #=> Complex

Returns the imaginary unit, which is C<sqrt(-1)>.

=head2 e

    Math::AnyNum->e                               #=> Float

Returns the I<e> mathematical constant, which is C<2.718...>.

=head2 pi

    Math::AnyNum->pi                              #=> Float

Returns the number PI, which is C<3.1415...>.

=head2 tau

    Math::AnyNum->tau                             #=> Float

Returns the number TAU, which is C<2*pi>.

=head2 ln2

    Math::AnyNum->ln2                             #=> Float

Returns the natural logarithm of C<2>.

=head2 phi

    Math::AnyNum->phi                             #=> Float

Returns the value of the golden ratio, which is C<1.61803...>.

=head2 EulerGamma

    Math::AnyNum->EulerGamma                      #=> Float

Returns the Euler-Mascheroni γ constant, which is C<0.57721...>.

=head2 CatalanG

    Math::AnyNum->CatalanG                        #=> Float

Returns the Catalan G constant, also known as C<Beta(2)>, which is C<0.91596...>.

=head1 ARITHMETIC OPERATIONS

This section includes basic arithmetic operations.

=head2 add

    x + y                                         #=> Any

Adds C<x> and C<y> and returns the result.

=head2 sub

    x - y                                         #=> Any

Subtracts C<y> from C<x> and returns the result.

=head2 mul

    x * y                                         #=> Any

Multiplies C<x> by C<y> and returns the result.

=head2 div

    x / y                                         #=> Any

Divides C<x> by C<y> and returns the result.

=head2 mod

    x % y                                         #=> Any
    mod(x, y)                                     #=> Any

Remainder of C<x> when is divided by C<y>. Returns NaN when C<y> is zero.

Implemented as:

    x % y = x - y*floor(x/y)

=head2 polymod

    polymod(n, a, b, c, ...)                      #=> (Any, Any, ..., Any)

Returns a list of mod results corresponding to the divisors in C<(a, b, c, ...)>. The divisors are
given from smallest "unit" to the largest (e.g. 60 seconds per minute, 60 minutes per hour) and the results
are returned in the same way: from smallest to the largest (5 seconds, 4 minutes).

Example:

    my ($s, $m, $h, $d) = polymod($seconds, 60, 60, 24);

=head2 conj

    conj(x)                                       #=> Float | Complex

Complex conjugate of C<x>. Returns C<x> when C<x> is a real number.

Example:

    conj("3+4i") = 3-4*i

=head2 inv

    inv(x)                                        #=> Any

Multiplicative inverse of C<x>. Equivalent with C<1/x>.

=head2 neg

    neg(x)                                        #=> Any

Additive inverse of C<x>. Equivalent with C<-x>.

=head2 abs

    abs(x)                                        #=> Any

Absolute value of C<x>.

=head2 sqr

    sqr(x)                                        #=> Any

Multiplies C<x> with itself and returns the result. Equivalent with C<x*x>.

=head2 norm

    norm(x)                                       #=> Any

The square of the absolute value of C<x>. Equivalent with C<abs(x)**2>.

=head1 SPECIAL FUNCTIONS

This section includes the special functions.

=head2 sqrt

    sqrt(x)                                       #=> Float | Complex

Square root of C<x>. Returns a complex number when C<x> is negative.

=head2 cbrt

    cbrt(x)                                       #=> Float | Complex

Cube root of C<x>. Returns a complex number when C<x> is negative.

=head2 root

    root(x, y)                                    #=> Float | Complex

The C<y> root of C<x>. Equivalent with C<x**(1/y)>.

=head2 polygonal_root

    polygonal_root(n, k)                          #=> Float | Complex

Returns the k-gonal root of C<n>. Also defined for complex numbers.

Example:

    say polygonal_root($n, 3);      # triangular root
    say polygonal_root($n, 5);      # pentagonal root

=head2 polygonal_root2

    polygonal_root2(n, k)                         #=> Float | Complex

Returns the second k-gonal root of C<n>. Also defined for complex numbers.

Example:

    say polygonal_root2($n, 5);      # second pentagonal root

=head2 pow

    x ** y                                        #=> Any
    pow(x, y)                                     #=> Any

Raises C<x> to power C<y> and returns the result.

When C<x> and C<y> are both integers, it does integer exponentiation and returns the exact result.

When C<x> is rational and C<y> is an integer, it does rational exponentiation based on the identity: C<(a/b)**n = a**n / b**n>,
which also computes the exact result.

Otherwise, it does floating-point exponentiation, which is equivalent with C<exp(log(x) * y)>.

=head2 exp

    exp(x)                                        #=> Float | Complex

Natural exponentiation of C<x> (i.e.: C<e**x>).

=head2 exp2

    exp2(x)                                       #=> Any

Raises 2 to the power C<x>. (i.e.: C<2**x>)

=head2 exp10

    exp10(x)                                      #=> Any

Raises 10 to the power C<x>. (i.e.: C<10**x>)

=head2 ln | log

    ln(x)                                         #=> Float | Complex
    log(x)                                        #=> Float | Complex
    log(x, y)                                     #=> Float | Complex

Logarithm of C<x> to base C<y> (or base I<e> when C<y> is omitted).

B<NOTE:> C<log(x, y)> is equivalent with C<log(x) / log(y)>.

=head2 log2 | log10

    log2(x)                                       #=> Float | Complex
    log10(x)                                      #=> Float | Complex

Logarithm of C<x> to base 2 and base 10, respectively.

=head2 lgrt

    lgrt(x)                                       #=> Float | Complex

Logarithmic-root of C<x>, which is the solution to C<a**a = x>, where C<x> is known.
When the value of C<x> is less than C<e**(-1/e)>, it returns a complex number.

It also accepts a complex number as input.

Example:

     lgrt(100)          # solves for x in `x**x = 100` and returns: `3.59728...`

This function is related to the Lambert-W function via the following identities:

    log(lgrt(exp(x)))     = LambertW(x)
    exp(LambertW(log(x))) = lgrt(x)

=head2 LambertW

    LambertW(x)                                   #=> Float | Complex

The Lambert-W function. When the value of C<x> is less than C<-1/e>, it returns a complex number.

It also accepts a complex number as input.

Identities (assuming x>0):

     LambertW(exp(x)*x) = x
     LambertW(log(x)*x) = log(x)

=head2 bernreal

    bernreal(n)                                   #=> Float

Returns the n-th Bernoulli number, as a floating-point approximation, with C<bernreal(1) = 0.5>.

=head2 lnbern

    lnbern(n)                                     #=> Float | Complex

Returns the natural logarithm of the n-th Bernoulli number.

=head2 harmreal

    harmreal(n)                                   #=> Float

Returns the n-th Harmonic number, as a floating-point approximation, for any real value of C<n>.

Returns NaN for negative integers.

Defined as:

    harmreal(n) = digamma(n+1) + γ

where C<γ> is the Euler-Mascheroni constant.

=head2 agm

    agm(x, y)                                     #=> Float | Complex

Arithmetic-geometric mean of C<x> and C<y>. Also defined for complex numbers.

=head2 hypot

    hypot(x, y)                                   #=> Float | Complex

The value of the hypotenuse for catheti C<x> and C<y>. Equivalent to C<sqrt(x**2 + y**2)>. Also defined for complex numbers.

=head2 gamma

    gamma(x)                                      #=> Float

The Gamma function on C<x>. Returns Inf when C<x> is zero, and NaN when C<x> is a negative integer.

=head2 lgamma

    lgamma(x)                                     #=> Float

Natural logarithm of the absolute value of the Gamma function.

=head2 lngamma

    lngamma(x)                                    #=> Float

Natural logarithm of the Gamma function for which the logarithm is a real number. Returns NaN otherwise.

=head2 lnsuperfactorial

    lnsuperfactorial(n)                           #=> Float

Natural logarithm of C<superfactorial(n)>, where C<n> is a non-negative integer.

=head2 lnhyperfactorial

    lnsuperfactorial(n)                           #=> Float

Natural logarithm of C<hyperfactorial(n)>, where C<n> is a non-negative integer.

=head2 digamma

    digamma(x)                                    #=> Float

The Digamma function (sometimes called Psi).
Returns NaN when C<x> is negative, and -Inf when C<x> is 0.

=head2 beta

    beta(x, y)                                    #=> Float

The beta function (also called the Euler integral of the first kind).

Defined as:

    beta(x, y) = gamma(x)*gamma(y) / gamma(x+y)

=head2 zeta

    zeta(x)                                       #=> Float

The Riemann zeta function at C<x>. Returns Inf when C<x> is 1.

=head2 eta

    eta(x)                                        #=> Float

The Dirichlet eta function at C<x>.

Defined as:

    eta(1) = ln(2)
    eta(x) = (1 - 2**(1-x)) * zeta(x)

=head2 BesselJ

    BesselJ(x, n)                                 #=> Float

The first order Bessel function, C<J_n(x)>, where C<n> is a signed integer.

Example:

    BesselJ(x, n)        # represents J_n(x)

=head2 BesselY

    BesselY(x, n)                                 #=> Float

The second order Bessel function, C<Y_n(x)>, where C<n> is a signed integer. Returns NaN for negative values of C<x>.

Example:

    BesselY(x, n)        # represents Y_n(x)

=head2 erf

    erf(x)                                        #=> Float

The error function on C<x>.

=head2 erfc

    erfc(x)                                       #=> Float

Complementary error function on C<x>.

=head2 Ai

    Ai(x)                                         #=> Float

The Airy function on C<x>.

=head2 Ei

    Ei(x)                                         #=> Float

Exponential integral of C<x>. Returns -Inf when C<x> is zero, and NaN when C<x> is negative.

=head2 Li

    Li(x)                                         #=> Float

The logarithmic integral of C<x>, defined as: C<Ei(ln(x))>.
Returns -Inf when C<x> is 1, and NaN when C<x> is less than or equal to C<0>.

=head2 Li2

    Li2(x)                                        #=> Float

The dilogarithm function, defined as the integral of C<-log(1-t)/t> from C<0> to C<x>.

=head1 TRIGONOMETRIC FUNCTIONS

=head2 sin | sinh | asin | asinh

    sin(x)                                        #=> Float | Complex
    sinh(x)                                       #=> Float | Complex
    asin(x)                                       #=> Float | Complex
    asinh(x)                                      #=> Float | Complex

Sine, hyperbolic sine, inverse sine and inverse hyperbolic sine.

=head2 cos | cosh | acos | acosh

    cos(x)                                        #=> Float | Complex
    cosh(x)                                       #=> Float | Complex
    acos(x)                                       #=> Float | Complex
    acosh(x)                                      #=> Float | Complex

Cosine, hyperbolic cosine, inverse cosine and inverse hyperbolic cosine.

=head2 tan | tanh | atan | atanh

    tan(x)                                        #=> Float | Complex
    tanh(x)                                       #=> Float | Complex
    atan(x)                                       #=> Float | Complex
    atanh(x)                                      #=> Float | Complex

Tangent, hyperbolic tangent, inverse tangent and inverse hyperbolic tangent.

=head2 cot | coth | acot | acoth

    cot(x)                                        #=> Float | Complex
    coth(x)                                       #=> Float | Complex
    acot(x)                                       #=> Float | Complex
    acoth(x)                                      #=> Float | Complex

Cotangent, hyperbolic cotangent, inverse cotangent and inverse hyperbolic cotangent.

=head2 sec | sech | asec | asech

    sec(x)                                        #=> Float | Complex
    sech(x)                                       #=> Float | Complex
    asec(x)                                       #=> Float | Complex
    asech(x)                                      #=> Float | Complex

Secant, hyperbolic secant, inverse secant and inverse hyperbolic secant.

=head2 csc | csch | acsc | acsch

    csc(x)                                        #=> Float | Complex
    csch(x)                                       #=> Float | Complex
    acsc(x)                                       #=> Float | Complex
    acsch(x)                                      #=> Float | Complex

Cosecant, hyperbolic cosecant, inverse cosecant and inverse hyperbolic cosecant.

=head2 atan2

    atan2(x, y)                                   #=> Float | Complex

The arc tangent of C<x> and C<y>, defined as:

    atan2(x, y) = -i * log((y + x*i) / sqrt(x^2 + y^2))

=head2 deg2rad

    deg2rad(x)                                    #=> Float | Complex

Returns the value of C<x> converted from degrees to radians.

Example:

    deg2rad(180) = pi

=head2 rad2deg

    rad2deg(x)                                    #=> Float | Complex

Returns the value of C<x> converted from radians to degrees.

Example:

    rad2deg(pi) = 180

=head1 INTEGER FUNCTIONS

All operations in this section are done with integers.

=head2 iadd | isub | imul | ipow

    iadd(x, y)                                    #=> Int | NaN
    isub(x, y)                                    #=> Int | NaN
    imul(x, y)                                    #=> Int | NaN
    ipow(x, y)                                    #=> Int | NaN

Integer addition, subtraction, multiplication and exponentiation.

=head2 idiv | idiv_ceil | idiv_round | idiv_trunc

    idiv(x, y)                                    #=> Int | NaN
    idiv_ceil(x, y)                               #=> Int | NaN
    idiv_trunc(x, y)                              #=> Int | NaN
    idiv_round(x, y)                              #=> Int | NaN

Integer division: C<floor(a/b)>, C<ceil(a/b)>, C<trunc(a/b)>, C<round(a/b)>.

=head2 ipow2

    ipow2(n)                                      #=> Int

Raises C<2> to the power C<n>, by first truncating C<n> to an integer.
Returns C<0> when C<n> is negative.

=head2 ipow10

    ipow10(n)                                     #=> Int

Raises C<10> to the power C<n>, by first truncating C<n> to an integer.
Returns C<0> when C<n> is negative.

=head2 imod

    imod(x, y)                                    #=> Int | NaN

The integer modulus operation. Returns NaN when C<y> is zero.

=head2 addmod

    addmod(a, b, m)                               #=> Int | NaN

Modular integer addition: C<(a+b) % m>.

    say addmod(43, 97, 127)     # == (43+97)%127

=head2 submod

    submod(a,b,m)                                 #=> Int | NaN

Modular integer subtraction: C<(a-b) % m>.

    say submod(43, 97, 127)     #=> (43-97)%127

=head2 mulmod

    mulmod(a,b,m)                                 #=> Int | NaN

Modular integer multiplication: C<(a*b) % m>.

    say mulmod(43, 97, 127)     # == (43*97)%127

=head2 divmod

    divmod(a, b)                                  #=> (Int, Int) | (NaN, NaN)
    divmod(a, b, m)                               #=> (Int, Int) | (NaN, NaN)

When only two arguments are provided, it returns C<(idiv(a,b), imod(a,b))>.

When three arguments are given, it does integer modular division: C<(a/b) % m>.

    say divmod(43, 97, 127)     # == (43 * invmod(97, 127))%127

=head2 invmod

    invmod(x, y)                                  #=> Int | NaN

Computes the multiplicative inverse of C<x> modulo C<y> and returns the result.

When no inverse exists (i.e.: C<gcd(x, y) != 1>), the NaN value is returned.

=head2 powmod

    powmod(x, y, z)                               #=> Int | NaN

Computes C<(x ** y) % z>, where all three values are integers.

Returns NaN when the third argument is 0, or when C<y> is negative and C<gcd(x, z) != 1>.

=head2 quadratic_powmod

    quadratic_powmod(a, b, w, n, m)               #=> Int | NaN

Computes C<(a + b*sqrt(w))**n % m>, returning C<(x,y)> satisfying:

    x + y*sqrt(w) == (a + b*sqrt(w))**n (mod m)

=head2 isqrt | icbrt

    isqrt(n)                                      #=> Int | NaN
    icbrt(n)                                      #=> Int | NaN

The integer square root of C<n> and the integer cube root of C<n>. Returns NaN when a real root does not exists.

=head2 isqrtrem

    isqrtrem(n)                                   #=> (Int, Int) | (NaN, NaN)

The integer part of the square root of C<n> and the remainder C<n - isqrt(n)**2>, which will be zero when C<n> is a perfect square.

=head2 iroot

    iroot(n, m)                                   #=> Int | NaN

The integer C<m-th> root of C<n>. Returns NaN when a real does not exists.

=head2 irootrem

    irootrem(n, m)                                #=> (Int, Int) | (NaN, NaN)

The integer part of the root of C<n> and the remainder C<n - iroot(n,m)**m>.

Returns C<(NaN,NaN)> when a real root does not exists.

=head2 ilog

    ilog(n)                                       #=> Int | NaN
    ilog(n, m)                                    #=> Int | NaN

The integer part of the logarithm of C<n> to base C<m> or base I<e> when C<m> is not specified.

C<n> must be greater than 0 and C<m> must be greater than 1. Returns NaN otherwise.

=head2 ilog2 | ilog10

    ilog2(n)                                      #=> Int | NaN
    ilog10(n)                                     #=> Int | NaN

The integer part of the logarithm of C<n> to base C<2> or base C<10>, respectively.

=head2 and | or | xor | not | lsft | rsft

    x & y                                         #=> Int
    x | y                                         #=> Int
    x ^ y                                         #=> Int
    ~x                                            #=> Int
    x << y                                        #=> Int
    x >> y                                        #=> Int

The bitwise integer operations.

=head2 lcm

    lcm(@list)                                    #=> Int

The least common multiple of a list of integers.

=head2 gcd

    gcd(@list)                                    #=> Int

The greatest common divisor of a list of integers.

=head2 gcdext

    gcdext(n, k)                                  #=> (Int, Int, Int)

The extended greatest common divisor of C<n> and C<k>, returning C<(u, v, d)>, where C<d> is
the greatest common divisor of C<n> and C<k>, while C<u> and C<v> are the coefficients satisfying
C<u*n + v*k = d>. The value of C<d> is always non-negative.

=head2 valuation

    valuation(n, k)                               #=> Scalar

Returns the number of times C<n> is divisible by C<k>.

=head2 remdiv

    remdiv(n, k)                                  #=> Int

Removes all occurrences of the divisor C<k> from integer C<n>.

In general, the following statement holds true:

    remdiv(n, k) == n / k**(valuation(n, k))

=head2 kronecker

    kronecker(n, m)                               #=> Scalar

Returns the Kronecker symbol I<(n|m)>, which is a generalization of the Jacobi symbol for all integers I<m>.

=head2 faulhaber_sum

    faulhaber_sum(n, k)                           #=> Int | NaN

Computes the power sum C<1^k + 2^k + 3^k +...+ n^k>, using Faulhaber's formula.

The value for C<k> must be a non-negative integer. Returns NaN otherwise.

Example:

    faulhaber_sum(5, 2) = 1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 55

=head2 geometric_sum

    geometric_sum(n, r)                           #=> Any

Computes the geometric sum C<1 + r + r^2 + r^3 + ... + r^n>, using the following formula:

    geometric_sum(n, r) = (r^(n+1) - 1) / (r - 1)

Example:

    geometric_sum(5, 8) = 8^0 + 8^1 + 8^2 + 8^3 + 8^4 + 8^5 = 37449

=head2 dirichlet_sum

    dirichlet_sum(n, \&f, \&g, \&F, \&G)          #=> Int | NaN

Given two arithmetic functions C<f> and C<g>, it computes the following sum in C<O(sqrt(n))> steps:

    Sum_{k=1..n} Sum_{d|k} f(d) * g(k/d)

The C<F> and C<G> functions are the partial sums of C<f> and C<g>, respectively:

    F(n) = Sum_{k=1..n} f(k)
    G(n) = Sum_{k=1..n} g(k)

However, this method is fast only when C<F(n)> and C<G(n)> can be computed efficiently.

Example:

    # Computes:
    #   Sum_{k=1..10^9} sigma_2(k) (C.f. A188138)

    dirichlet_sum(
        10**9,                              # n
        sub { 1 },                          # f
        sub { $_[0]**2 },                   # g
        sub { $_[0] },                      # F(n) = Sum_{k=1..n} f(k)
        sub { faulhaber_sum($_[0], 2) },    # G(n) = Sum_{k=1..n} g(k)
    )

=head2 harmonic | harmfrac

    harmonic(n)                                   #=> Rat | NaN

Returns the n-th Harmonic number C<H_n>. The harmonic numbers are the sum of
reciprocals of the first C<n> natural numbers: C<1 + 1/2 + 1/3 + ... + 1/n>.

For values greater than 7000, binary splitting (Fredrik Johansson's elegant formulation) is used.

=head2 secant_number

    secant_number(n)                              #=> Int

Returns the n-th secant number (A000364), starting with C<secant_number(0) = 1>.

=head2 tangent_number

    tangent_number(n)                             #=> Int

Returns the n-th tangent number (A000182), starting with C<tangent_number(1) = 1>.

=head2 bernoulli_polynomial

    bernoulli_polynomial(n, x)                    #=> Any

Returns the n-th Bernoulli polynomial: C<B_n(x)>.

=head2 faulhaber_polynomial | faulhaber

    faulhaber_polynomial(n, x)                        #=> Any

Returns the n-th Faulhaber polynomial: C<F_n(x)>.

=head2 euler_polynomial

    euler_polynomial(n, x)                        #=> Any

Returns the n-th Euler polynomial: C<E_n(x)>.

=head2 bernoulli | bernfrac

    bernoulli(n)                                  #=> Rat | NaN
    bernoulli(n, x)                               #=> Any

Returns the n-th Bernoulli number C<B_n> as an exact fraction, with C<bernoulli(1) = 1/2>.

When an additional argument is provided, it returns the n-th Bernoulli polynomial: C<B_n(x)>.

=head2 euler

    euler(n)                                      #=> Rat | NaN
    euler(n, x)                                   #=> Any

Returns the n-th Euler number C<E_n>, starting with C<euler(0) = 1>.

When an additional argument is provided, it returns the n-th Euler polynomial: C<E_n(x)>.

=head2 lucas

    lucas(n)                                      #=> Int | NaN

The n-th Lucas number. Returns NaN when C<n> is negative.

=head2 lucasU

    lucasU(P, Q, n)                               #=> Int | NaN

The Lucas C<U_n(P, Q)> function.

Example:

    lucasU(1, -1, $n)       # the Fibonacci numbers
    lucasU(2, -1, $n)       # the Pell numbers
    lucasU(1, -2, $n)       # the Jacobsthal numbers

=head2 lucasV

    lucasV(P, Q, n)                               #=> Int | NaN

The Lucas C<V_n(P, Q)> function.

Example:

    lucasV(1, -1, $n)       # the Lucas numbers
    lucasV(2, -1, $n)       # the Pell-Lucas numbers
    lucasV(1, -2, $n)       # the Jacobsthal-Lucas numbers

=head2 lucasmod

    lucasmod(n, m)                                #=> Int | NaN

Efficiently compute the n-th Lucas number modulo m.

=head2 lucasUmod

    lucasUmod(P, Q, n, m)                         #=> Int | NaN

Efficiently compute the Lucas C<U_n(P, Q)> function modulo m.

=head2 lucasVmod

    lucasVmod(P, Q, n, m)                         #=> Int | NaN

Efficiently compute the Lucas C<V_n(P, Q)> function modulo m.

=head2 fibonacci

    fibonacci(n)                                  #=> Int | NaN
    fibonacci(n, k)                               #=> Int | NaN

The n-th Fibonacci number. Returns NaN when C<n> is negative.

When C<k> is specified, it returns the k-th order Fibonacci number.

Example:

    say fibonacci(100, 3);        # 100th Tribonacci number
    say fibonacci(100, 4);        # 100th Tetranacci number
    say fibonacci(100, 5);        # 100th Pentanacci number

=head2 fibmod

    fibmod(n, m)                                  #=> Int | NaN

Efficiently compute the n-th Fibonacci number modulo m.

=head2 chebyshevT

    chebyshevT(n, x)                              #=> Any

Compute the Chebyshev polynomials of the first kind: C<T_n(x)>, where C<n> must be a native integer.

Defined as:

    T(0, x) = 1
    T(1, x) = x
    T(n, x) = 2*x*T(n-1, x) - T(n-2, x)

=head2 chebyshevU

    chebyshevU(n, x)                              #=> Any

Compute the Chebyshev polynomials of the second kind: C<U_n(x)>, where C<n> must be a native integer.

Defined as:

    U(0, x) = 1
    U(1, x) = 2*x
    U(n, x) = 2*x*U(n-1, x) - U(n-2, x)

=head2 laguerreL

    laguerreL(n, x)                               #=> Any

Compute the Laguerre polynomials: C<L_n(x)>, where C<n> must be a non-negative native integer.

=head2 legendreP

    legendreP(n, x)                               #=> Any

Compute the Legendre polynomials: C<P_n(x)>, where C<n> must be a non-negative native integer.

=head2 hermiteH

    hermiteH(n, x)                                #=> Any

Compute the physicists' Hermite polynomials: C<H_n(x)>, where C<n> must be a non-negative native integer.

=head2 hermiteHe

    hermiteHe(n, x)                               #=> Any

Compute the probabilists' Hermite polynomials: C<He_n(x)>, where C<n> must be a non-negative native integer.

=head2 factorial

    factorial(n)                                  #=> Int | NaN

Factorial of C<n> (denoted as C<n!>). Returns NaN when C<n> is negative. (C<1*2*3*...*n>)

=head2 dfactorial

    dfactorial(n)                                 #=> Int | NaN

Double-factorial of C<n> (denoted as C<n!!>). Returns NaN when C<n> is negative. (requires GMP>=5.1.0)

Example:

    dfactorial(7)     # 1*3*5*7 = 105
    dfactorial(8)     # 2*4*6*8 = 384

=head2 mfactorial

    mfactorial(n, m)                              #=> Int | NaN

Generalized m-factorial of C<n>. Returns NaN when C<n> or C<m> is negative. (requires GMP>=5.1.0)

=head2 subfactorial

    subfactorial(n)                               #=> Int | NaN
    subfactorial(n, k)                            #=> Int | NaN

The number of permutations of C<{1, ..., n}> that have exactly C<k> fixed points,
given a positive integer C<n> and an optional integer C<k> (if C<k> is omitted, then C<k=0>).

See also:

=over 4

=item * L<https://en.wikipedia.org/wiki/Rencontres_numbers>

=back

=head2 superfactorial

    superfactorial(n)                             #=> Int | NaN

Product of first C<n> factorials: C<Prod_{k=1..n} k!>.

=head2 hyperfactorial

    hyperfactorial(n)                             #=> Int | NaN

Hyperfactorial of C<n>, defined as: C<Prod_{k=1..n} k^k>.

=head2 bell

    bell(n)                                       #=> Int | NaN

Returns the n-th Bell number.

=head2 catalan

    catalan(n)                                    #=> Int | NaN
    catalan(n, k)                                 #=> Int | NaN

Returns the n-th Catalan number.

If two arguments are provided, it returns the C<C(n,k)> entry in Catalan's triangle.

=head2 binomial

    binomial(n, k)                                #=> Int | NaN

Computes the binomial coefficient C<n> over C<k>, also called the
"choose" function. The result is equivalent to:

                        n!
    binomial(n, k) = -------
                     k!(n-k)!

=head2 multinomial

    multinomial(a, b, c, ...)                     #=> Int | NaN

Computes the multinomial coefficient, given a list of native integers.

Example:

    multinomial(1, 4, 4, 2) = 34650

See also:

=over 4

=item * L<https://en.wikipedia.org/wiki/Multinomial_theorem>

=back

=head2 rising_factorial

    rising_factorial(n, k)                        #=> Int | Rat | NaN

Rising factorial, C<n * (n + 1) * ... * (n + k - 1)>, defined as:

    binomial(n + k - 1, k) * k!

For negative values of C<k>, rising factorial is defined as:

    rising_factorial(n, -k) = 1/rising_factorial(n - k, k)

When the denominator is zero, NaN is returned.

=head2 falling_factorial

    falling_factorial(n, k)                       #=> Int | Rat | NaN

Falling factorial, C<n * (n - 1) * ... * (n - k + 1)>, defined as:

    binomial(n, k) * k!

For negative values of C<k>, falling factorial is defined as:

    falling_factorial(n, -k) = 1/falling_factorial(n + k, k)

When the denominator is zero, NaN is returned.

=head2 primorial

    primorial(n)                                  #=> Int | NaN

Returns the product of all the primes less than or equal to C<n>. (requires GMP>=5.1.0)

=head2 next_prime

    next_prime(n)                                 #=> Int | NaN

Returns the next prime after C<n>.

=head2 is_prime

    is_prime(n, r=23)                             #=> Scalar

Returns 2 if C<n> is definitely prime, 1 if C<n> is probably prime (without being certain), or 0 if C<n> is definitely composite.

This method does some trial divisions, then C<r> Miller-Rabin probabilistic primality tests.

A higher C<r> value reduces the chances of a composite being identified as "probably prime". Reasonable values of C<r> are between 20 and 50.

Starting with GMP 6.2.0, a Baillie-PSW probable prime test is performed, which has no known counter-examples.
By specifying a value of r > 24, if C<n> passes the B-PSW test, C<r-24> additional Miller-Rabin tests are performed.

See also:

=over 4

=item * L<https://en.wikipedia.org/wiki/Miller–Rabin_primality_test>

=item * L<https://en.wikipedia.org/wiki/Baillie%E2%80%93PSW_primality_test>

=item * L<https://gmplib.org/manual/Number-Theoretic-Functions.html>

=back

=head2 is_coprime

    is_coprime(n, k)                              #=> Bool

Returns true when C<n> and C<k> are relatively prime to each other. That is, when C<gcd(n, k) == 1>.

=head2 make_coprime

    make_coprime(n, k)                            #=> Int | NaN

Returns the largest divisor of C<n> that is coprime to C<k>.

=head2 is_rough

    is_rough(n, k)                                #=> Bool

Returns true when all the prime factors of C<n> are greater than or equal to C<k>, where C<n> and C<k> are positive integers.

Equivalently, it returns true if the B<smallest> prime factor of C<n> is greater than or equal to C<k>.

Example:

    is_rough(55, 7)    # false  : 55 = 5 * 11, where 5 < 7
    is_rough(35, 5)    # true   : 35 = 5 * 7

=head2 is_smooth

    is_smooth(n, k)                               #=> Bool

Returns true when all the prime factors of C<n> are less than or equal to C<k>, where C<n> and C<k> are positive integers.

Equivalently, it returns true if the B<largest> prime factor of C<n> is less than or equal to C<k>.

Example:

    is_smooth(36, 3)    # true  : 36 = 2^2 * 3^2
    is_smooth(39, 6)    # false : 39 = 3 * 13, where 13 > 6

=head2 is_smooth_over_prod

    is_smooth_over_prod(n, k)                     #=> Bool

Returns true if C<n> can be expressed as a product of primes dividing C<k>.

Equivalently, it returns true if C<gcd(rad(n), rad(k)) == rad(n)>.

Example:

    is_smooth_over_prod(42, 2*3*7*11)   # true because 42 = 2*3*7
    is_smooth_over_prod(75, 3*5)        # true because 75 = 3*5*5
    is_smooth_over_prod($n, 3*5*7*11)   # true for odd 11-smooth numbers $n

=head2 smooth_part

    smooth_part(n, k)                             #=> Int | NaN

Returns the largest divisor of C<n> that is C<k>-smooth.

Example:

    smooth_part(3*3*5*7,  5)    # 45 (= 3*3*5)
    smooth_part(5*7*7*11, 6)    # 5

=head2 rough_part

    rough_part(n, k)                              #=> Int | NaN

Returns the largest divisor of C<n> that is C<k>-rough.

Example:

    rough_part(3*3*5*7,  5)    # 35  (= 5*7)
    rough_part(5*7*7*11, 6)    # 539 (= 7*7*11)

=head2 is_square

    is_square(n)                                  #=> Bool

Returns true when C<n> is a perfect square.
When C<n> is not an integer, a false value is returned.

=head2 is_power

    is_power(n)                                   #=> Bool
    is_power(n, k)                                #=> Bool

Returns true when C<n> is a perfect power of a given integer C<k>.

When C<n> is not an integer, it always returns false. On the other hand, when C<k> is not an integer,
it will implicitly be truncated to an integer. If C<k> is not positive after truncation, C<0> is returned.

A true value is returned iff there exists some integer C<a> satisfying the equation: C<a**k = n>.

When C<k> is not specified, it returns true if C<n> can be expressed as C<a**b> for some integers C<a> and C<b>, with C<b> greater than 1.

Example:

    is_power(100, 2)       # true: 100 is a square (10**2)
    is_power(125, 3)       # true: 125 is a cube   ( 5**3)
    is_power(279841)       # true: 279841 is 23**4

=head2 is_power_of

    is_power_of(n, b)                             #=> Bool

Return true if C<n> is a power of C<b>, such that C<n = b**k> for some k >= 0.

Example:

    64->is_power_of(2)     # true: 64 is a power of 2 (64 = 2**6)
    27->is_power_of(3)     # true: 27 is a power of 3 (27 = 3**3)

=head2 polygonal

    polygonal(n, k)                               #=> Int

Returns the nth k-gonal number. When C<n> is negative, it returns the second k-gonal number.

Example:

    say join(' ', map { polygonal( $_, 3) } 1..10);  # triangular numbers
    say join(' ', map { polygonal( $_, 5) } 1..10);  # pentagonal numbers
    say join(' ', map { polygonal(-$_, 5) } 1..10);  # second pentagonal numbers

=head2 ipolygonal_root

    ipolygonal_root(n, k)                         #=> Int | NaN

Integer k-gonal root of C<n>. Returns NaN when a real root does not exists.

Example:

    say ipolygonal_root($n, 5);                  # integer pentagonal root
    say ipolygonal_root(polygonal(10, 5), 5);    # prints: "10"

=head2 ipolygonal_root2

    ipolygonal_root2(n, k)                        #=> Int | NaN

Second integer k-gonal root of C<n>. Returns NaN when a real root does not exists.

Example:

    say ipolygonal_root2($n, 5);                   # second integer pentagonal root
    say ipolygonal_root2(polygonal(-10, 5), 5);    # prints: "-10"

=head2 is_polygonal

    is_polygonal(n, k)                            #=> Bool

Returns true when C<n> is a k-gonal number.

The values of C<n> and C<k> can be any arbitrary large integers.

Example:

    say is_polygonal(145, 5);      #=> 1 ("145" is a pentagonal number)
    say is_polygonal(155, 5);      #=> 0

=head2 is_polygonal2

    is_polygonal2(n, k)                           #=> Bool

Returns true when C<n> is a second k-gonal number.

The values of C<n> and C<k> can be any arbitrary large integers.

Example:

    say is_polygonal2(145, 5);      #=> 0
    say is_polygonal2(155, 5);      #=> 1 ("155" is a second-pentagonal number)

=head1 MISCELLANEOUS

This section includes various useful methods.

=head2 min | max

    min(@list)                                    #=> Any
    max(@list)                                    #=> Any

Smallest and greatest value, respectively, from a given list of numbers.

Returns C<undef> if the list contains C<NaN> or if the list is empty.

=head2 sum | prod

    sum(@list)                                    #=> Any
    prod(@list)                                   #=> Any

Sum and product of a given list of numbers.

=head2 bsearch

    bsearch(n, \&f)                               #=> Int | undef
    bsearch(a, b, \&f)                            #=> Int | undef

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a subroutine reference which does the comparisons.

This function finds a value C<k> such that f(k) = 0. Returns C<undef> otherwise.

    bsearch(20,      sub { $_*$_  <=> 49   });   #=> 7   (7*7  = 49)
    bsearch(3, 1000, sub { $_**$_ <=> 3125 });   #=> 5   (5**5 = 3125)

=head2 bsearch_le

    bsearch_le(n, \&f)                            #=> Int | undef
    bsearch_le(a, b, \&f)                         #=> Int | undef

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a subroutine reference which does the comparisons.

This function finds a value C<k> such that f(k) <= 0 and f(k+1) > 0. Returns C<undef> otherwise.

    bsearch_le(10**6,         sub { exp($_) <=> 1e+9 });  #=>  20   (exp( 20) <= 1e+9)
    bsearch_le(-10**6, 10**6, sub { exp($_) <=> 1e-9 });  #=> -21   (exp(-21) <= 1e-9)

=head2 bsearch_ge

    bsearch_ge(n, \&f)                            #=> Int | undef
    bsearch_ge(a, b, \&f)                         #=> Int | undef

Binary search from to C<0> to C<n>, or from C<a> to C<b>, which can be any arbitrary large integers.

The last argument is a subroutine reference which does the comparisons.

This function finds a value C<k> such that f(k-1) < 0 and f(k) >= 0. Returns C<undef> otherwise.

    bsearch_ge(10**6,         sub { exp($_) <=> 1e+9 });  #=>  21   (exp( 21) >= 1e+9)
    bsearch_ge(-10**6, 10**6, sub { exp($_) <=> 1e-9 });  #=> -20   (exp(-20) >= 1e-9)

=head2 floor

    floor(x)                                      #=> Any

Returns C<x> if C<x> is an integer, otherwise it rounds C<x> towards -Infinity.

Example:

    floor( 2.5) =  2
    floor(-2.5) = -3

=head2 ceil

    ceil(x)                                       #=> Any

Returns C<x> if C<x> is an integer, otherwise it rounds C<x> towards +Infinity.

Example:

    ceil( 2.5) =  3
    ceil(-2.5) = -2

=head2 round

    round(x)                                      #=> Any
    round(x, p)                                   #=> Any

Rounds C<x> to the nth place. A negative argument rounds that many digits
after the decimal point, while a positive argument rounds that many digits
before the decimal point.

Example:

    round('1234.567')         = 1235
    round('1234.567', 2)      = 1200
    round('3.123+4.567i', -2) = 3.12+4.57*i

=head2 rand

    rand(x)                                       #=> Float
    rand(x, y)                                    #=> Float

Returns a pseudorandom floating-point value. When an additional argument is provided,
it returns a number between C<x> (inclusive) and C<y> (exclusive). Otherwise, returns a number between
C<0> (inclusive) and C<x> (exclusive).

If C<x> is greater than C<y>, the returned value will be in the range C<[y, x)>.

The PRNG behind this function is called the "Mersenne Twister". Although it generates pseudorandom
numbers of very good quality, B<it is NOT cryptographically secure>. You should not rely on it in
security-sensitive situations.

Example:

    rand(10)        # a pseudorandom floating-point in the interval [0, 10)
    rand(10, 20)    # a pseudorandom floating-point in the interval [10, 20)

=head2 irand

    irand(x)                                      #=> Int
    irand(x, y)                                   #=> Int

Returns a pseudorandom integer. Unlike the C<rand()> function, C<irand()> is inclusive in both sides.

When an additional argument is provided, it returns an integer between C<x> (inclusive) and C<y> (inclusive),
otherwise returns an integer between C<0> (inclusive) and C<x> (inclusive).

If C<x> is greater than C<y>, the returned integer will be in the range C<[y, x]>.

The PRNG behind this function is called the "Mersenne Twister". Although it generates high-quality
pseudorandom integers, B<it is NOT cryptographically secure>. You should not rely on it in
security-sensitive situations.

Example:

    irand(10)        # a pseudorandom integer in the interval [0, 10]
    irand(10, 20)    # a pseudorandom integer in the interval [10, 20]

=head2 seed | iseed

    seed(n)                                       #=> Int
    iseed(n)                                      #=> Int

Reseeds the C<rand()> and the C<irand()> function, respectively, with the value of C<n>, which can be any arbitrary large integer.

Returns back the integer part of C<n>. If C<n> cannot be truncated to an integer,
the method dies with an appropriate error message.

=head2 sgn

    sgn(x)                                        #=> Scalar | Complex

Returns C<-1> when C<x> is negative, C<1> when C<x> is positive, and C<0> when C<x> is zero.

When C<x> is a complex number, it computes the sign using the identity:

    sgn(x) = x / abs(x)

=head2 length

    $n->length                                    #=> Scalar
    $n->length($base)                             #=> Scalar

Returns the number of digits of the integer part of C<n> in a given base (default 10).

Example:

    5040->length        # size in base 10
    5040->length(2)     # size in base 2

Returns C<undef> when C<n> cannot be truncated to an integer.

=head2 inc

    ++$x                                          #=> Any
    $x++                                          #=> Any

Returns C<x + 1>.

=head2 dec

    --$x                                          #=> Any
    $x--                                          #=> Any

Returns C<x - 1>.

=head2 copy

    $x->copy                                      #=> Any

Returns a deep-copy of the self-object.

=head2 popcount

    popcount(n)                                   #=> Scalar

Returns the population count of the positive integer part of C<x>, which is the number of 1's in
its binary representation.

Returns C<undef> when C<n> cannot be truncated to an integer.

This value is also known as the Hamming weight value.

Example:

    popcount(0b1011) = 3

=head2 hamdist

    hamdist(n, k)                                 #=> Scalar

Returns the Hamming distance (number of bit-positions where the bits differ) between integers C<n> and C<k>.

Returns C<undef> when C<n> or C<k> cannot be truncated to an integer.

=head2 getbit

    getbit(n, k)                                  #=> Bool

Returns 1 if bit C<k> of C<n> is set, and 0 if it is not set.

Returns C<undef> when C<n> cannot be truncated to an integer or when C<k> is negative.

Example:

    getbit(0b1001, 0) = 1
    getbit(0b1000, 0) = 0

=head2 setbit

    setbit(n, k)                                  #=> Int

Returns a copy of C<n> with bit C<k> set to 1.

Example:

    setbit(0b1000, 0) = 0b1001
    setbit(0b1000, 2) = 0b1100

=head2 flipbit

    flipbit(n, k)                                 #=> Int

Returns a copy of C<n> with bit C<k> inverted.

Example:

    flipbit(0b1000, 0) = 0b1001
    flipbit(0b1001, 0) = 0b1000

=head2 clearbit

    clearbit(n, k)                                #=> Int

Returns a copy of C<n> with bit C<k> set to 0.

Example:

    clearbit(0b1001, 0) = 0b1000
    clearbit(0b1100, 2) = 0b1000

=head2 bit_scan0 | bit_scan1

    bit_scan0(n, k)                               #=> Scalar
    bit_scan1(n, k)                               #=> Scalar

Scan C<n>, starting from bit index C<k>, towards more significant bits, until 0 or 1 bit (respectively) is found.

When C<k> is omitted, C<k=0> is assumed.

Returns C<undef> if C<n> cannot be truncated to an integer or if C<k> is negative.

=head1 * Introspection

=head2 is_int

    is_int(x)                                     #=> Bool

Returns true when C<x> is an integer.

=head2 is_rat

    is_rat(x)                                     #=> Bool

Returns true when C<x> is a rational number.

=head2 is_real

    is_real(x)                                    #=> Bool

Returns true when C<x> is a real number (i.e.: when the imaginary part is zero and it holds a real value in the real part).

Example:

    is_real(complex('4'))           # true
    is_real(complex('4i'))          # false (is imaginary)
    is_real(complex('3+4i'))        # false (is complex)

=head2 is_imag

Returns true when C<x> is an imaginary number (i.e.: when the real part is zero and it has a non-zero imaginary part).

Example:

    is_imag(complex('4'))           # false (is real)
    is_imag(complex('4i'))          # true
    is_imag(complex('3+4i'))        # false (is complex)

=head2 is_complex

    is_complex(x)                                 #=> Bool

Returns true when C<x> is a complex number (i.e.: when the real part and the imaginary part are non-zero).

Example:

    is_complex(complex('4'))        # false (is real)
    is_complex(complex('4i'))       # false (is imaginary)
    is_complex(complex('3+4i'))     # true

=head2 is_even

    is_even(n)                                    #=> Bool

Returns true when C<n> is a real integer divisible by 2.

=head2 is_odd

    is_odd(n)                                     #=> Bool

Returns true when C<n> is a real integer not divisible by 2.

=head2 is_div

    is_div(n, k)                                  #=> Bool

Returns true when C<n> is exactly divisible by C<k> (i.e.: when the remainder C<n % k> is zero).

Also defined for rationals, floats and complex numbers.

=head2 is_congruent

    is_congruent(n, k, m)                         #=> Bool

Returns true when C<n> is congruent to C<k> modulo C<m> (i.e.: when the remainder C<n % m> equals C<k % m>).

Also defined for rationals, floats and complex numbers.

=head2 is_pos

    is_pos(x)                                     #=> Bool

Returns true when C<x> is positive.

=head2 is_neg

    is_neg(x)                                     #=> Bool

Returns true when C<x> is negative.

=head2 is_zero

    is_zero(n)                                    #=> Bool

Returns true when C<n> equals 0.

=head2 is_one

    is_one(n)                                     #=> Bool

Returns true when C<n> equals 1.

=head2 is_mone

    is_mone(n)                                    #=> Bool

Returns true when C<n> equals -1.

=head2 is_inf

    is_inf(x)                                     #=> Bool

Returns true when C<x> holds the positive Infinity special value.

=head2 is_ninf

    is_ninf(x)                                    #=> Bool

Returns true when C<x> holds the negative Infinity special value.

=head2 is_nan

    is_nan(x)                                     #=> Bool

Returns true when C<x> holds the Not-a-Number special value.

=head1 * Conversions

=head2 int

    int(x)                                        #=> Int | NaN

Returns the integer part of C<x>. Returns NaN when C<x> cannot be truncated to an integer.

=head2 rat

    rat(x)                                        #=> Rat | NaN
    rat(str)                                      #=> Rat | NaN

Converts C<x> to a rational number. Returns NaN when this conversion is not possible.

When the given argument is a decimal expansion string, it will be specially parsed as an exact fraction.

If C<x> is a floating-point real number, consider using C<rat_approx()> instead.

Example:

    rat('0.5')       = 1/2
    rat('1234/5678') = 617/2839

=head2 rat_approx

    rat_approx(n)                                 #=> Rat | NaN

Given a real number C<n>, it returns a very good (sometimes exact) rational approximation to C<n>, computed with continued fractions.

Example:

    rat_approx(3.14)     = 22/7
    rat_approx(zeta(-5)) = -1/252

Returns NaN when C<n> is not a real number.

=head2 ratmod

    ratmod(r, m)                                  #=> Int | NaN

Given a rational number C<r> and an integer C<m>, it returns C<r % m> computed as an integer.

Example:

    ratmod('43/97', 127) = 79

Equivalent with:

    (numerator($r) * invmod(denominator($r), $m)) % $m

=head2 float

    float(x)                                      #=> Float | Complex
    float(str)                                    #=> Float | Complex

Converts C<x> to a real or a complex floating-point number (in this order).

Example:

    float(3.1415926) = 3.1415926   (as Float)
    float('777/222') = 3.5         (as Float)
    float('123+45i') = 123 + 45*i  (as Complex)

=head2 complex

    complex(x)                                    #=> Complex
    complex(str)                                  #=> Complex
    complex(x, y)                                 #=> Complex

Converts C<x> to a complex number. When a second argument is given, it sets C<x> as the real part and C<y> as the imaginary part.

If C<x> or C<y> are complex numbers, the function returns the result of C<x + y*i>.

Example:

    complex("3+4i")        = 3+4*i
    complex(3, 4)          = 3+4*i
    complex("5+2i", "-4i") = 9+2*i

=head2 stringify

    "$x"                                          #=> Scalar

Returns a string representing the value of C<x>, in base 10.

=head2 boolify

    !!$x                                          #=> Bool

Returns a false value when the number is zero or when the value of the number is C<NaN>. True otherwise.

=head2 numify

    $x->numify                                    #=> Scalar

Returns a Perl numerical scalar containing the value of C<x>, truncated if necessary.

If C<x> is an integer that fits inside a native signed or unsigned integer, the returned result will be exact,
otherwise the result is returned as a double, with possible truncation.

If C<x> is a complex number, only the real part is considered.

=head2 base

    base(n, b)                                    #=> Scalar

Returns a string-representation of C<n> in a given base C<b> (between 2 and 62), where C<n> can be any type of number, including a floating-point or a complex number.

Example:

    base(42, 2)         = "101010"
    base(17.5, 36)      = "h.i"
    base("99/43", 16)   = "63/2b"
    base("17.5+5i", 36) = "(h.i 5)"

The output of this function can be passed to I<new()>, along with the base-number, which converts it back to the original number:

    say Math::AnyNum->new("101010", 2);    #=> 42
    say Math::AnyNum->new("h.i", 36);      #=> 17.5

=head2 as_bin

    as_bin(n)                                     #=> Scalar

Returns a string representing the integer part of C<n> in binary (base 2).

Example:

    as_bin(42) = "101010"

Returns C<undef> when C<n> cannot be converted to an integer.

=head2 as_oct

    as_oct(n)                                     #=> Scalar

Returns a string representing the integer part of C<n> in octal (base 8).

Example:

    as_oct(42) = "52"

Returns C<undef> when C<n> cannot be converted to an integer.

=head2 as_hex

    as_hex(n)                                     #=> Scalar

Returns a string representing the integer part of C<n> in hexadecimal (base 16).

Example:

    as_hex(42) = "2a"

Returns C<undef> when C<n> cannot be converted to an integer.

=head2 as_int

    as_int(n)                                     #=> Scalar
    as_int(n, b)                                  #=> Scalar

Returns the integer part of C<n> as a string, in a given base, where the base must be between 2 and 62.

When the base is omitted, it defaults to base 10.

Example:

    as_int(255)     = "255"
    as_int(255, 16) = "ff"

Returns C<undef> when C<n> cannot be converted to an integer.

=head2 as_rat

    as_rat(n)                                     #=> Scalar
    as_rat(n, b)                                  #=> Scalar

Returns C<n> as a rational string-representation in a given base, where the base must be between 2 and 62.

When the base is omitted, it defaults to base 10.

Example:

    as_rat(42)      = "42"
    as_rat("2/4")   = "1/2"
    as_rat(255, 16) = "ff"

Returns C<undef> when C<n> cannot be converted to a rational number.

=head2 as_frac

    as_frac(n)                                    #=> Scalar | undef
    as_frac(n, b)                                 #=> Scalar | undef

Returns C<n> as a fraction in a given base, where the base must be between 2 and 62.

When the base is omitted, it defaults to base 10.

Example:

    as_frac(42)      = "42/1"
    as_frac("2/4")   = "1/2"
    as_frac(255, 16) = "ff/1"

Returns C<undef> when C<n> cannot be converted to a rational number.

=head2 as_dec

    as_dec(n)                                     #=> Scalar
    as_dec(n, digits)                             #=> Scalar

Returns C<n> as a decimal expansion string, with an optional number of digits.

When the second argument is undefined, it uses the default precision.

The value of C<n> can also be a complex number.

Example:

    as_dec(1/2)        = "0.5"
    as_dec(sqrt(2), 3) = "1.41"

=head1 * Dissections

=head2 numerator

    numerator(x)                                  #=> Int | NaN

Returns the numerator of C<x> as a signed C<Math::AnyNum> object. When C<x> is not a rational number,
it tries to convert it to a rational. Returns NaN when this conversion is not possible.

Example:

    numerator("-42")  = -42
    numerator("-3/4") = -3

=head2 denominator

    denominator(x)                                #=> Int | NaN

Returns the denominator of C<x> as an unsigned C<Math::AnyNum> object. When C<x> is not a rational number,
it tries to convert it to a rational. Returns NaN when this conversion is not possible.

Example:

    denominator("-42")  = 1
    denominator("-3/4") = 4

=head2 nude

    nude(x)                                       #=> (Int | NaN, Int | NaN)

Returns the numerator and the denominator of C<x>.

Example:

    nude("42")   = (42, 1)
    nude("-3/4") = (-3, 4)

=head2 real

    real(x)                                       #=> Any

Returns the real part of C<x>.

Example:

    real("42")   = 42
    real("42i")  = 0
    real("3-4i") = 3

=head2 imag

    imag(x)                                       #=> Any

Returns the imaginary part of C<x>, if any. Otherwise, returns zero.

Example:

    imag("42")   =  0
    imag("42i")  = 42
    imag("3-4i") = -4

=head2 reals

    reals(x)                                      #=> (Any, Any)

Returns the real and the imaginary part of C<x> as real numbers.

Example:

    reals("42")   = (42, 0)
    reals("42i")  = (0, 42)
    reals("3-4i") = (3, -4)

=head2 digits

    digits(n)                                     #=> (Scalar, Scalar, ...)
    digits(n, b)                                  #=> (Scalar | Int, Scalar | Int, ...)

Returns a list with the digits of C<n> in a given base. When no base is specified, it defaults to base 10.

Only the absolute integer part of C<n> is considered.

The value of C<b> must be greater than C<1>. Returns an empty list otherwise.

Example:

    digits(12345)      = (5, 4, 3, 2, 1)
    digits(12345, 100) = (45, 23, 1)

=head2 digits2num

    digits2num([...], b=10)                       #=> Int | NaN

Takes an array-ref of digits (in reverse order) and an optional base (default 10), converting the digits to an integer in the given base.

The value of C<b> must be greater than C<1>. Returns NaN otherwise.

Example:

    digits2num([5, 4, 3, 2, 1])  = 12345
    digits2num([45, 23, 1], 100) = 12345

=head2 sumdigits

    sumdigits(n)                                  #=> Int | NaN
    sumdigits(n, b)                               #=> Int | NaN

Sum the digits of C<n> in a given base. When no base is specified, it defaults to base 10.

Only the absolute integer part of C<n> is considered.

The value of C<b> must be greater than C<1>. Returns NaN otherwise.

Example:

    sumdigits(12345)      = 15
    sumdigits(12345, 100) = 69

=head1 * Comparisons

=head2 eq

    x == y                                        #=> Bool

Equality check: returns a true value when C<x> and C<y> are equal.

=head2 ne

    x != y                                        #=> Bool

Inequality check: returns a true value when C<x> and C<y> are not equal.

=head2 gt

    x > y                                         #=> Bool

Returns true when C<x> is greater than C<y>.

=head2 ge

    x >= y                                        #=> Bool

Returns true when C<x> is equal or greater than C<y>.

=head2 lt

    x < y                                         #=> Bool

Returns true when C<x> is less than C<y>.

=head2 le

    x <= y                                        #=> Bool

Returns true when C<x> is equal or less than C<y>.

=head2 cmp

    x <=> y                                       #=> Scalar

Compares C<x> to C<y> and returns a negative value when C<x> is less than C<y>,
0 when C<x> and C<y> are equal, and a positive value when C<x> is greater than C<y>.

Complex numbers are compared as:

    (real(x) <=> real(y)) ||
    (imag(x) <=> imag(y))

Comparing anything to NaN (including NaN itself), returns C<undef>.

=head2 acmp

    acmp(x, y)                                    #=> Scalar

Absolute comparison of C<x> and C<y>.

Defined as:

    acmp(x, y) = abs(x) <=> abs(y)

=head2 approx_cmp

    approx_cmp(x, y)                              #=> Scalar
    approx_cmp(x, y, k)                           #=> Scalar

Approximate comparison, by rounding the values of C<x> and C<y> at a given number of decimal places.

A negative value for C<k> rounds that many digits after the decimal point, while a positive value rounds before the decimal point.

When no value is given for C<k>, it uses the default precision - 1.

=head1 PERFORMANCE

The performance varies greatly, but, in most cases, Math::AnyNum is between 2x up to 10x
faster than L<Math::BigFloat> with the B<GMP> backend, and about 100x faster than L<Math::BigFloat>
without the B<GMP> backend (to be modest).

Math::AnyNum is fast because of the following facts:

=over 4

=item *

minimal overhead in object creations and conversions.

=item *

minimal Perl code is executed per operation.

=item *

the B<GMP>, B<MPFR> and B<MPC> libraries are extremely efficient.

=back

To achieve the best performance, try to:

=over 4

=item *

use the B<i*> functions/methods wherever applicable.

=item *

use floating-point numbers when accuracy is not important.

=item *

pass Perl integers as arguments to methods, if you can.

=back

=head1 MOTIVATION

This module came into existence as a response to Dana Jacobsen's request for a transparent
interface to L<Math::GMPz> and L<Math::MPFR>, which he talked about at the YAPC NA, in 2015.

See his great presentation at: L<https://www.youtube.com/watch?v=Dhl4_Chvm_g>.

The main aim of this module is to provide a fast and correct alternative to L<Math::BigInt>,
L<Math::BigFloat> and L<Math::BigRat>, as well as to L<bigint>, L<bignum> and L<bigrat> pragmas.

The original project was called C<Math::BigNum>, but because of some design flaws, that project
was abandoned and much of its code ended up in this module.

=head1 SEE ALSO

=over 4

=item * Fast math libraries

L<Math::GMP> - High speed arbitrary size integer math.

L<Math::GMPz> - perl interface to the GMP library's integer (mpz) functions.

L<Math::GMPq> - perl interface to the GMP library's rational (mpq) functions.

L<Math::MPFR> - perl interface to the MPFR (floating point) library.

L<Math::MPC> - perl interface to the MPC (multi precision complex) library.

=item * Portable math libraries

L<Math::BigInt> - Arbitrary size integer/float math package.

L<Math::BigFloat> - Arbitrary size floating point math package.

L<Math::BigRat> - Arbitrary big rational numbers.

=item * Math utilities

L<Math::Prime::Util> - Utilities related to prime numbers, including fast sieves and factoring.

L<Math::GComplex> - Generic library for complex number operations, with support for Gaussian integers.

=back

=head1 REPOSITORY

L<https://github.com/trizen/Math-AnyNum>

=head1 AUTHOR

Daniel Șuteu, C<< <trizen at cpan.org> >>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2017-2021 Daniel Șuteu

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.22.0 or,
at your option, any later version of Perl 5 you may have available.

=cut
